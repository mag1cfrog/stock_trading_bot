# 2024-12-18 - Storage Design Pattern Benchmarks and DuckDB vs SQLite Comparison

Today we focused on benchmarking different storage design patterns for our DuckDB-based data storage system, and compared DuckDB against SQLite for our use case.

## Storage Design Pattern Benchmarks

Today we focused on benchmarking different storage design patterns for our DuckDB-based data storage system. We created comprehensive benchmark tests to evaluate three different storage patterns:

### Storage Design Patterns Tested

1. **Option 1 (Single Database)**: All data stored in a single DuckDB database with separate tables for each symbol and timeframe
2. **Option 2 (Hierarchical Structure)**: Data distributed across multiple databases following a hierarchical folder structure (symbol/timeframe/data)
3. **Option 3 (Symbol-Based Division)**: One database per symbol, with separate tables for different timeframes

### Benchmark Results

We tested these patterns under two scenarios:

#### Moderate Load (10 symbols, 100,000 rows)
- **Option 1** (Single DB): Best overall performance
  - Create: 0.11s ± 0.02s
  - Append: 5.45s ± 0.12s
  - Query: 0.03s ± 0.00s
  - Total: 5.59s ± 0.14s

- **Option 2** (Hierarchical): Highest overhead
  - Create: 0.60s ± 0.04s
  - Append: 10.72s ± 0.12s
  - Query: 0.40s ± 0.00s
  - Total: 11.71s ± 0.16s

- **Option 3** (Symbol-Based): Moderate performance
  - Create: 0.28s ± 0.03s
  - Append: 7.05s ± 0.05s
  - Query: 0.12s ± 0.01s
  - Total: 7.44s ± 0.07s

#### Heavy Load (50 symbols, 500,000 rows)
- **Option 1**: Good create/query, but append becomes bottleneck
  - Create: 0.55s ± 0.05s
  - Append: 96.72s ± 0.76s
  - Query: 0.30s ± 0.00s
  - Total: 97.57s ± 0.71s

- **Option 2**: Highest overhead across all operations
  - Create: 3.26s ± 0.14s
  - Append: 142.30s ± 1.49s
  - Query: 2.96s ± 0.01s
  - Total: 148.53s ± 1.62s

- **Option 3**: Best overall performance for large datasets
  - Create: 1.75s ± 0.01s
  - Append: 73.11s ± 0.08s
  - Query: 0.80s ± 0.01s
  - Total: 75.67s ± 0.10s

### Key Findings
1. Using OS's folder hierarchical structure (Option 2) introduces significant overhead
2. Single database approach (Option 1) works best for smaller datasets
3. Symbol-based division (Option 3) scales better with larger datasets
4. The performance difference becomes more pronounced as the data size increases

## DuckDB vs SQLite Comparison

We also conducted a benchmark comparing DuckDB against SQLite for our use case, addressing the common perception about SQLite's transactional capabilities.

### Results
- **DuckDB**:
  - Create: 0.002s
  - Insert: 0.027s
  - Query: 0.003s

- **SQLite**:
  - Create: 0.003s
  - Insert: 0.624s
  - Query: 0.034s

### Key Findings
1. DuckDB significantly outperforms SQLite in our use case
2. Particularly notable is the ~23x faster insert performance in DuckDB
3. Query performance in DuckDB is ~13x faster than SQLite
4. Even for transactional workloads, DuckDB proves to be more efficient in our specific use case

## Next Steps
1. Implement the optimal storage pattern based on our expected data volume
2. Consider implementing a hybrid approach that can switch between Option 1 and Option 3 based on data size
3. Further optimize the chosen pattern for specific query patterns
4. Consider benchmarking concurrent access patterns